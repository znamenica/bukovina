#!/usr/bin/env ruby
#coding: utf-8

require 'yaml'
require 'date'
require 'rdoba'
require 'rdoba/dup'
require 'open-uri'
require 'nokogiri'
require 'hashie'
require 'fileutils'
require 'petrovich'
require 'mechanize'

rdoba :mixin => [ :case ], :log => { :functions => [ :* ] }

def добава куда, име, нечто
   case куда[ име ]
   when Array
      if !куда[ име ].include? нечто
         куда[ име ] << нечто ; end
   when Hash, String
      if куда[ име ].is_a?( Hash ) &&
         куда[ име ].select {| _, нечто | нечто && !нечто.empty? }.empty?
         куда[ име ] = нечто
      elsif куда[ име ] != нечто
         куда[ име ] = [ куда[ име ], нечто ] ; end
   when NilClass
      куда[ име ] = нечто
   end
end

def общя_замена словеса
   map = {
      /[Сс]вященномучен/i => 'сщмч.',
      /пресвитер/ => '',
   }
   словеса.split( /\s+/ ).map do| слово |
      замена = map.select {| к, з | слово =~ к }
      замена.empty? && слово || замена.to_a.last.last ; end.join ' ' ; end

def добавить_память people, person
   if person.имя.empty? || person.имя =~ /^[а-я]+$/
      return person ; end

   people << person
   log > { 'Добавлена память' => person }
   self.new_person ; end

def search_for services, name
   service = services[ name ]
   if service
      return service ; end
   names = name.split( '/' )[ 0 ].split /\s+/

   if names.size > 1
      services.each do| key, value |
         key = key.split( '/' )[ 0 ]
         if names.reject {| n | key.include? n }.empty?
            return value ; end ; end ; end
   nil ; end

def assign_trops trops, people, services
   service_tmpl = YAML.load( IO.read 'service.yml' )
   trops.each do| trop |
      ( names, glas, text, cases ) = yield trop
      mls = parse_trop( names, glas, text, cases ) do | names |
         log >> { trop_names: names }
         if names.size > 1
            return names ; end
         found = people.keys.select do | key |
            key.split( /\s+/ ).select {| name | names[ 0 ] == name }.size > 0
            end
         found.size > 0 && found.last.split( /\s+/ ) || names ; end

      log >> { people: { mls[ 0 ] => mls[ 1 ] } }
      if people[ mls[ 0 ] ]
         case people[ mls[ 0 ] ][ 'служба' ]
         when NilClass
            people[ mls[ 0 ] ].merge! mls[ 1 ]
         when String
            people[ mls[ 0 ] ][ 'служба' ] =
            [ people[ mls[ 0 ] ][ 'служба' ], mls[ 1 ][ 'служба' ] ].uniq
         when Array
            ( people[ mls[ 0 ] ][ 'служба' ] << mls[ 1 ][ 'служба' ] ).uniq!
         end
      else
         people.merge!( mls[ 0 ] => mls[ 1 ] ) ;end

      name = "#{mls[ 1 ][ 'служба' ]}.цс_ро.yml"
      value = mls[ 2 ]
      service = search_for( services, name ) || service_tmpl.dup( :recursive )
      log >> { name: name, services: services[ name ] }
   
      case value[ 0 ]
      when 'тропарь'
         добава service['вечерня']['отпустительно'], 'тропарь',
                { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
      when 'молитва'
         добава service['вечерня']['отпустительно'], 'молитва',
                value[ 2 ]
      when 'кондак'
         добава service['утреня']['канон'], 'кондак',
                { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
      when 'величание'
         добава service['утреня'], 'величание',
                value[ 2 ]
      end
      services[ name ] = service
   end
end

def parse_trop names, glas, text, cases
   if names[ 0 ] =~ /[Ии]н/
      names.shift ; end
   kind = names.shift.downcase

   чин = names[ 0 ] =~ /^[а-яё]/ && names.shift || ''

   род =
   if чин =~ /мученицы|преподобной|праведной/ || names[ 0 ] =~ /Божией/i
      :female
   else
      :male ; end
   petro = Petrovich.new род

   fname = ''
   names =
   names.select do| name |
      name =~ /[А-ЯЁ]/ &&
      name !~ /Божией|Матери|Ее|Пресвят|Богородице|Ея|Свято|Крещен|Священномучени/
   end.map do| name |
      def apply_cases petro, method, cases, name
         cases = cases.is_a?( Array ) && cases || [ cases ]
         new =
         cases.each do| c |
            new = petro.send method, name, :nominative, c
            if new != name
               break new ; end ; end
         new.is_a?( Array ) && name || new ; end

      name.gsub! /[«»]+/, ''
      if fname.empty?
         fname = apply_cases petro, :firstname, cases, name
      else
         apply_cases petro, :lastname, cases, name ; end ; end

   names = yield names
   name = names.join ' '
   fservice = petro.firstname names.shift, :dative
   lservice = names.map {| i | petro.lastname i, :dative }
   service = ( [ fservice ] | lservice | [ 'служба' ] ).join ' '
   
   [ name, { 'служба' => "#{name}/#{service}" }, [ kind, glas, text ] ] ; end

def заверка_прозвища person, name
   if !person.прозвище.include?( name ) && !person.фамилия.include?( name ) &&
      !person.описание.include?( name )
      person.прозвище = ( person.прозвище.split( ' ' ) << name ).join ' '
      end ; end

def azbuka_p p
   drevo_person_line p, nil, 'бытие' ; end

def drevo_person_line li, base = 'http://drevo-info.ru', store_name = 'вики'
   def new_person
      person = Hashie::Mash.new
      person.имя = ''
      person.прозвище = []
      person.фамилия = []
      person.описание = []
      person.чин = nil
      person.год = nil
      person.собор = nil
      person.служба = nil
      person.вики = nil
      person.бытие = nil
      person.отечник = nil
      person.образ = []
      person ; end

   def set_name person, name
      names = name.split /\s+/
      имя = ''
      names.map! do| и |
         if !имя.empty? || и !~ /^[А-ЯЁ]/
            next и ; end
         имя = и.strip
         nil ; end.compact!
      log >> { 'Имя' => имя }
      person.имя = имя
      if names.join =~ /икон/
         log >> { "Описание + " => names }
         person.описание |= names
      else
         log >> { "Прозвище + " => names }
         person.прозвище |= names ; end ; end

   def proc_parts parts, person
      parts.each_index do| i |
         part = parts[ i ].strip
         if part =~ /^[а-яё]/ && part !~ /прмч|сщмч|мч/ || part =~ /^\(.*[\d\w\)]+.*\)$/
            begin
               if !parts[ i - 1 ].empty?
                  parts[ i - 1 ] << ' ' ; end
               parts[ i - 1 ] << part
               parts[ i ] = nil
            rescue
               parts[ i ] = part ; end
         else
            parts[ i ] = part ; end ; end
      parts.compact ; end

   people = []
   mark = nil
   person = self.new_person
   parts = []
   text = ''

   # expanding groups
   lis = li.children.to_a.map do| li_e |
      if li_e.is_a?( Nokogiri::XML::Element ) && li_e.attr( 'href' ) =~ /group/
         url = li_e.attr( 'href' )
         uri = url =~ /^http/ && url || ( base + url )
         azbuka_group = Nokogiri::HTML( open( uri ), nil, 'utf-8' )
         azbuka_group.css( "#featured .cont h1" ).children.to_a
      else
         li_e ; end ; end.flatten

   lis.each do| li_e |
      if li_e.is_a? Nokogiri::XML::Comment
         next ; end
      text = li_e.content.gsub( /[<!«»:]|--/, '' ).gsub( / +/, ' ' ).strip #NBSP to Space here
      log * ( '&'*80 )
      log >> { text: text }
      if li_e.is_a?( Nokogiri::XML::Element )
         log * "Ссылка"
         text = общя_замена text
         if text =~ /^[а-яёА-ЯЁ]/ && !person.имя.empty?
            person = добавить_память people, person ; end

         if text =~ /^(?:([А-ЯЁа-яё]+)\.|Иконы?)(.*)$/
            person.чин = ( $1 || 'обр' ).downcase
            person.имя = $2.gsub( /[,.<!]/, '' ).strip
         elsif !text.empty?
            if !person.имя.empty?
               person.имя << ' ' ; end
            person.имя << text.gsub( /[,.<!]/, '' ).strip ; end

         if li_e.name == 'a' && text !~ /[\d\w]/ &&
            li_e.attr( 'href' ) !~ /find|p-znaki|p-san|p-tip/
            url = li_e.attr( 'href' )
            uri = url =~ /^http/ && url || ( base + url )
            person[ store_name ] = uri ; end

         log > { имя: person.имя }
      elsif text =~ /^(?:([А-ЯЁа-яё]+)\.|Икона Божией Матери|Священномучени[а-я]+)(.*)$/
         log * "Чин"
         (чин, имя) = [ $1, $2 ]
         if text =~ /(гг|н|э)\./ 
            person.имя << text
         else
            person.чин = ( чин || 'обр' ).downcase
            person.имя << имя.gsub( /[.,]/, '' ).strip
         end
         log > { имя: person.имя }
      elsif !text.empty?
         log * "Ино"
         if text =~ /(.*\))([^)])*$/
            person.имя << $1
            text = $2.to_s ; end

         text.split( /[;,]| ?и / ).each do| part |
            part = part.strip
            log >> { part: part }
            if part =~ /^[А-ЯЁ]/
               person = добавить_память people, person
               person.имя = part
            elsif part =~ /^([а-яё]+)\.|икон.*$/
               person = добавить_память people, person
               person.чин = ( $1 || 'обр' ).downcase
            elsif !part.empty?
               person.имя << ' ' + part ; end ; end
         log > { имя: person.имя } ; end ; end
   добавить_память people, person

   people.each_index do| i |
      person = people[ i ]
      mode = nil
      имя = person.имя
      person.имя = ''
      log > { 'Processing person' => person }
      имя.split( '(' ).each do| subtoken |
         subtoken = subtoken.strip
         log >> { 'Token' => subtoken }
         if subtoken =~ /^(.+)\)/
            if subtoken =~ /^(.*(\d|\w)+.*)\)/
               log >> 'Год'
               person.год = $1.strip.gsub( / - /, '-' ).gsub( /гг./, '' )
               mode = :год
            elsif subtoken =~ /^(.*)\)/
               if mode
                  log >> 'Собор'
                  person.собор = $1.to_s.gsub( /и\s/, ',' ).
                                 gsub( /[.\s]+/, '' ).downcase
                  mode = :собор
               else
                  log >> 'Фамилия'
                  person.фамилия |= $1.to_s.split( /[,\s]+/ )
                  mode = :фамилия ; end
            else
               $stderr.puts "Invalid token #{subtoken}" ; end
         elsif subtoken =~ /[А-Яа-я\-]+/
            set_name person, subtoken ; end ; end
      text = ''

      if person.чин?
         mark = person.чин[ -1 ] == person.чин[ -2 ] ; end ; end

   people.compact!

   # set чин
   чин = nil
   people.each do| person |
      if person.чин
         if person.чин[ -1 ] == person.чин[ -2 ]
            чин = person.чин[ 0..-2 ]
            person.чин = чин
         else
            чин = person.чин ; end
      else
         person.чин = чин ; end ; end

   # set год
   год = nil
   people.reverse.each do| person |
      if person.год
         год = person.год
      else
         person.год = год ; end ; end

   # Обращение падежей в именительный
   people.each do| person |
      def apply_lastname petro, name
         new = petro.lastname name, :nominative, :genitive
         if new != name
            return new ; end

         gen = petro.gender == 'male' && :female || :male
         new_petro = Petrovich.new gen
         new_petro.lastname name, :nominative, :genitive
      end
      gen =
      if person.чин =~ /мц|обр/
         :female
      elsif !person.чин
         :androgynous
      else
         :male ; end
      petro = Petrovich.new gen

      if person.описание
         person.описание.map! do| v |
            apply_lastname petro, v ; end ; end

      if person.фамилия
         person.фамилия.map! do| v |
            apply_lastname petro, v ; end ; end

      if person.прозвище
         person.прозвище.map! do| v |
            apply_lastname petro, v ; end ; end

      if person.имя
         имя = petro.firstname person.имя, :nominative, :genitive
         if имя = person.имя
            имя = petro.lastname person.имя, :nominative, :genitive ; end
         person.имя = имя ; end ; end ; end

def parse_list list, shift = 0
   def detect_uniq_name person, shift
      url =
      if person.вики
         log >> { вики: person.вики }
         person.вики
      elsif person.бытие
         log >> { бытие: person.бытие }
         person.бытие
      end
      person_doc = Nokogiri::HTML( ( open url), nil, 'utf-8' )
      name = person_doc.css( 'h1' ).text.downcase
      if name =~ /икона/
         shift = 2 ; end
      parts = name.strip.split( /\s+/ )[ shift, 2 ]
      parts.each do| part |
         part.gsub!( /[,«»\d\)\(]+/, '' )
         part[ 0 ] = part[ 0 ].upcase
      end.join( ' ' ) ; end

   people = {}
   list.each do| person |
      log >> { person: person }
      name =
      if !person.имя.empty?
         вторки = [ person.фамилия, person.прозвище ].flatten.compact
         вторка = вторки.select {| имя | имя =~ /^[А-ЯЁ]/ }[ 0 ]
         [ person.имя, вторка ].compact.join ' ' ; end

      if person.бытие || person.вики && ( !name || name !~ /\s/ )
         name = detect_uniq_name person, shift ; end

      log > { name: name }
      log >> '*'*80
      person.фамилия = person.фамилия.join ' '
      person.прозвище = person.прозвище.join ' '
      person.описание = person.описание.join ' '
      person.образ = !person.образ.empty? && person.образ || nil

      if name
         заверка_прозвища person, ( name.split( ' ' ).last || '' ) ; end
      people[ name ] = person.to_hash ; end
   people ; end

#date = ARGV.shift
date = Date.parse( ARGV.shift ) rescue Date.today
julian = date.julian
day = julian.day
month = julian.month
services = {}
people_set = []

Months = [ 'ЯНВАРЯ', 'ФЕВРАЛЯ', 'МАРТА', 'АПРЕЛЯ', 'МАЯ', 'ИЮНЯ',
           'ИЮЛЯ', 'АВГУСТА', 'СЕНТЯБРЯ', 'ОКТЯБРЯ', 'НОЯБРЯ', 'ДЕКАБРЯ' ]
month_str = Months[ month - 1 ]

log * "Search for #{day} #{month_str}\n\n"

# calendar
log * "Parse drevo-info.ru site"
log * ( "*"*80 )

uri = 'http://drevo-info.ru/articles/list/14.html?page='
date_link = 'http://drevo-info.ru' +
(1..4).each do| i |
   drevo_cal = Nokogiri::HTML( open "#{uri}#{i}" )
   li =
   drevo_cal.css( 'li' ).each do| li |
      if li.content == "#{day} #{month_str}" # check 27 НОЯБРЯ
         break li
      end
   end
   if li.is_a? Nokogiri::XML::Element
      break li.css( 'a' ).attr( 'href' ).value
   end
end

if date_link.is_a? String
   drevo_date = Nokogiri::HTML( open date_link )

   seg = drevo_date.css( 'h2' ).each do| h2 |
      if h2.text == 'Память'
         break h2 ; end ; end

   memlist = []
   if !seg.is_a? Array
      #TODO change to seg
      mem = drevo_date.css( '#article ul' )
      mem.css( 'li' ).each do| li |
         if li.content.strip =~ /^\d/
            next ; end
         ml = drevo_person_line li
         memlist |= ml
      end
   end
end

drevo_people = parse_list memlist


# Pravoslavie.ru parsing
log * "Parse Pravoslavie.ru site"
log * ( "*"*80 )

prav_people = {}

date_link = 'http://days.pravoslavie.ru/Days'
doc = open "#{date_link}/#{julian.strftime( "%Y%m%d" )}.htm"
prav_ru = Nokogiri::HTML doc.read

assign_trops( ( prav_ru.css '.trop' ),
              drevo_people, services ) do| trop |
   names = trop.css( '.trop_title' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.trop_glas' ).inner_text.strip
   text = trop.css( '.trop_text' ).inner_text.strip
   [ names, glas, text, :genitive ] ; end

people_set.push drevo_people


# Azbuka parsing
log * "Parse azbuka.ru site"
log * ( "*"*80 )

date_link = 'http://azbyka.ru/days'
doc = open "#{date_link}/#{date.strftime( "%Y-%m-%d" )}"
azbuka = Nokogiri::HTML doc.read, nil, 'utf-8'

memlist = []
ps = azbuka.css( '#calendar-wrapper .text p' )
ps.to_a.each_index do| i |
   if i == 0
      next ; end
   p = ps[ i ]
   ml = azbuka_p p
   memlist |= ml ; end

azbuka_people = parse_list memlist, 1
assign_trops( ( azbuka.css '.taks_block .taks_content' ),
              azbuka_people, services ) do| trop |
   names = trop.css( 'h3' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.glas' ).inner_text.strip rescue ''
   text = trop.css( 'div' ).inner_text.strip
   [ names, glas, text, [ :dative, :genitive ] ] ; end

people_set.push azbuka_people

# Merge people descriptions
log * "Merging the site data"
log * ( "*"*80 )

people = people_set.shift
people_set.each do| current_people |
   current_people.each do| name, person |
      if people.key? name
         log > { Merging: name }
         log >> { P1: people[ name ], P2: person }
         # deep merge
         people[ name ].keys.each do| key |
            people[ name ][ key ] =
            case people[ name ][ key ]
            when Array
               case person[ key ]
               when Array
                  ( people[ name ][ key ] | person.delete( key ) ).uniq
               when NilClass
                  people[ name ][ key ]
               when String
                  if person[ key ].strip.empty?
                     people[ name ][ key ]
                  else
                     ( people[ name ][ key ] | [ person.delete( key ) ] ).uniq ; end
               else
                  ( people[ name ][ key ] | [ person.delete( key ) ] ).uniq ; end
            when NilClass
               case person[ key ]
               when Array
                  person.delete( key )
               when NilClass
               when String
                  if !person[ key ].strip.empty?
                     person.delete( key ) ; end
               else
                  person.delete( key ) ; end
            when String
               if people[ name ][ key ].strip.empty?
                  case person[ key ]
                  when Array
                     person.delete( key )
                  when NilClass
                  when String
                     if !person[ key ].strip.empty?
                        person.delete( key ) ; end
                  else
                     person.delete( key ) ; end
               else
                  case person[ key ]
                  when Array
                     ( [ people[ name ][ key ] ] | person.delete( key ) ).uniq
                  when NilClass
                     people[ name ][ key ]
                  when String
                     if person[ key ].strip.empty?
                        people[ name ][ key ]
                     elsif person[ key ] == people[ name ][ key ]
                        person.delete( key )
                     else
                        ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq ; end
                  else
                     ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq ; end ; end
            else
               case person[ key ]
               when Array
                  ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq
               when NilClass
                  people[ name ][ key ]
               when String
                  if person[ key ].strip.empty?
                     people[ name ][ key ]
                  else
                     ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq ; end
               else
                  if person[ key ] == people[ name ][ key ]
                     person.delete( key )
                  else
                     ( [ people[ name ][ key ] ] | person.delete( key ) ).uniq ; end ; end ; end
         end
         person.each {| key, value | people[ name ][ key ] }
         log >> people[ name ]
      else
         people[ name ] = person ; end ; end ; end


# pravicon.com search

agent = Mechanize.new
#agent.user_agent_alias = 'Windows IE 9'

people.each do| name, value |
   if !name || name.empty?
      next ; end

   page = agent.get 'http://pravicon.com/'
   f = page.forms.first
   f.search = name
   f.selectdb = value[ 'чин' ] == 'обр' && 's' || 'b'
   begin
      content = f.submit( f.buttons.last ).content
      doc = Nokogiri::HTML content
   rescue
      next
   end
   uris = []
   doc.css( '#content a' ).each do| a |
      uris << ( 'http://pravicon.com' + a.attr( 'href' ) )
   end
   case uris.size
   when 0
   when 1
      value[ 'образ' ] = uris.last
   else
      value[ 'образ' ] = uris
   end
end


# Store the people data

folder = sprintf "мѣсѧцесловъ/%02i/%02i", month, day
FileUtils.mkdir_p folder
File.open( File.join( folder, 'месяцеслов.ро.yml' ), 'w' ) do| f |
   f.puts people.to_yaml.gsub( /  /, '   ' ).gsub( /'/, '' ).gsub( /\s+$/, '' )
end

services.each do| име, служба |
   име = име.split( '/' )
   FileUtils.mkdir_p File.join( folder, име[ 0 ] )
   File.open( File.join( folder, име[ 0 ], име[ 1 ] ), 'w' ) do| f |
      f.puts служба.to_yaml.gsub( /  /, '   ' ).gsub( / - /, '  - ' ).gsub( /'/, '' ).gsub( /\s+$/, '' )
   end
end


