#!/usr/bin/env ruby
#coding: utf-8

require 'yaml'
require 'date'
require 'rdoba'
require 'rdoba/dup'
require 'open-uri'
require 'nokogiri'
require 'hashie'
require 'fileutils'
require 'petrovich'

rdoba :mixin => [ :case ], :log => { :functions => [ :* ] }

def prav_ru_trop trop
   names = trop.css( '.trop_title' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.trop_glas' ).inner_text.strip
   text = trop.css( '.trop_text' ).inner_text.strip
   kind = names.shift.downcase

   род =
   if names[ 0 ] =~ /мученицы|преподобной|праведной|Божией/i
      :female
   else
      :male ; end
   petro = Petrovich.new род

   fname = ''
   names =
   names.select do| name |
      name =~ /[А-ЯЁ]/ && name !~ /Божией|Матери|Ее/
   end.map do| name |
      if fname.empty?
         fname = petro.firstname name, :nominative, :genitive
      else
         petro.lastname name, :nominative, :genitive ; end ; end
   name = names.join ' '
   fservice = petro.firstname names.shift, :dative
   lservice = names.map {| i | petro.lastname i, :dative }
   service = ( [ fservice ] | lservice | [ 'служба' ] ).join ' '
   
   [ name, { 'служба' => "#{name}/#{service}" }, [ kind, glas, text ] ] ; end

def azbuka_p p
   drevo_person_line p, nil, 'бытие' ; end

def drevo_person_line li, base = 'http://drevo-info.ru', store_name = 'вики'
   def new_person
      person = Hashie::Mash.new
      person.имя = ''
      person.прозвище = []
      person.фамилия = []
      person.описание = []
      person.чин = nil
      person.год = nil
      person.собор = nil
      person.служба = nil
      person.вики = nil
      person.бытие = nil
      person.отечник = nil
      person.образ = []
      person ; end

   def set_name person, name
      names = name.split /\s+/
      имя = names.shift
      person.имя = имя && имя.strip || nil
      if names.join =~ /икон/
         person.описание |= names
      else
         person.прозвище |= names ; end ; end

   def proc_parts parts, person
      parts.each_index do| i |
         part = parts[ i ].strip
         if part =~ /^[а-яё]/ && part !~ /прмч|сщмч|мч/ || part =~ /^\(.*[\d\w\)]+.*\)$/
            begin
               if !parts[ i - 1 ].empty?
                  parts[ i - 1 ] << ' ' ; end
               parts[ i - 1 ] << part
               parts[ i ] = nil
            rescue
               parts[ i ] = part ; end
         else
            parts[ i ] = part ; end ; end
      parts.compact ; end

   people = []
   mark = nil
   person = self.new_person
   parts = []
   text = ''
   li.children.each do| li_e |
      if li_e.is_a? Nokogiri::XML::Comment
         next ; end
      text = li_e.content.gsub( /[<!«»]|--/, '' ).gsub( / +/, ' ' ).strip #NBSP to Space here
      if li_e.is_a?( Nokogiri::XML::Element )
         if text =~ /^[а-яёА-ЯЁ]/ && !person.имя.empty?
            people << person
            person = self.new_person
         end

         if text =~ /^(?:([А-ЯЁа-яё]+)\.|Иконы?)(.*)$/
            person.чин = ( $1 || 'обр' ).downcase
            person.имя = $2.gsub( /[,.<!]/, '' ).strip
         elsif !text.empty?
            if !person.имя.empty?
               person.имя << ' ' ; end
            person.имя << text.gsub( /[,.<!]/, '' ).strip ; end

         if li_e.name == 'a' && li_e.attr( 'href' ) !~ /find|p-znaki/ && text !~ /[\d\w]/
            url = li_e.attr( 'href' )
            person[ store_name ] = url =~ /^http/ && url || ( base + url ) ; end
      elsif text =~ /^(?:([А-ЯЁа-яё]+)\.|Икон)(.*)$/
         person.чин = ( $1 || 'обр' ).downcase
         person.имя = $2.gsub( /[.,]/, '' ).strip
      elsif !text.empty?
         text.split( /[;,]/ ).each do| part |
            part = part.strip
            if part =~ /^[А-ЯЁ]/
               people << person
               person = self.new_person
               person.имя = part
            elsif part =~ /^([а-яё]+)\.|икон.*$/
               people << person
               person = self.new_person
               person.чин = ( $1 || 'обр' ).downcase
            elsif !part.empty?
               person.имя << ' ' + part ; end ; end ; end ; end
   people << person

   people.each_index do| i |
      person = people[ i ]
      mode = nil
      имя = person.имя
      person.имя = ''
      имя.split( '(' ).each do| subtoken |
         subtoken = subtoken.strip
         if subtoken =~ /^(.+)\)/
            if subtoken =~ /^(.*(\d|\w)+.*)\)/
               person.год = $1.strip
               mode = :год
            elsif subtoken =~ /^(.*)\)/
               if mode
                  person.собор = $1.to_s.gsub( /[.,\s]+/, '' ).downcase
                  mode = :собор
               else
                  person.фамилия |= $1.to_s.split( /[,\s]+/ )
                  mode = :фамилия ; end
            else
               $stderr.puts "Invalid token #{subtoken}" ; end
         elsif subtoken =~ /[А-Яа-я\-]+/
            set_name person, subtoken ; end ; end
      text = ''

      if person.чин?
         mark = person.чин[ -1 ] == person.чин[ -2 ] ; end ; end

   people.compact!

   # set чин
   чин = nil
   people.each do| person |
      if person.чин
         if person.чин[ -1 ] == person.чин[ -2 ]
            чин = person.чин[ 0..-2 ]
            person.чин = чин
         else
            чин = person.чин ; end
      else
         person.чин = чин ; end ; end

   # set год
   год = nil
   people.reverse.each do| person |
      if person.год
         год = person.год
      else
         person.год = год ; end ; end

   # Обращение падежей в именительный
   people.each do| person |
      gen =
      if person.чин =~ /мц|обр/
         :female
      elsif !person.чин
         :androgynous
      else
         :male ; end
      petro = Petrovich.new gen

      if person.описание
         person.описание.map! do| v |
            petro.lastname v, :nominative, :genitive ; end ; end

      if person.фамилия
         person.фамилия.map! do| v |
            petro.lastname v, :nominative, :genitive ; end ; end

      if person.прозвище
         person.прозвище.map! do| v |
            petro.lastname v, :nominative, :genitive ; end ; end

      if person.имя
         имя = petro.firstname person.имя, :nominative, :genitive
         if имя = person.имя
            имя = petro.lastname person.имя, :nominative, :genitive ; end
         person.имя = имя ; end ; end ; end

def parse_list list, shift = 0
   def detect_uniq_name person, shift
      url =
      if person.вики
         log >> { вики: person.вики }
         person.вики
      elsif person.бытие
         log >> { бытие: person.бытие }
         person.бытие
      end
      person_doc = Nokogiri::HTML( ( open url), nil, 'utf-8' )
      name = person_doc.css( 'h1' ).text.downcase
      if name =~ /икона/
         shift = 2 ; end
      parts = name.strip.split( /\s+/ )[ shift, 2 ]
      parts.each do| part |
         part.gsub!( /[,«»\d\)\(]+/, '' )
         part[ 0 ] = part[ 0 ].upcase
      end.join( ' ' ) ; end

   people = {}
   list.each do| person |
      log >> { person: person }
      name =
      if person.бытие || person.вики && person.имя.empty?
         detect_uniq_name person, shift
      else
         [ person.имя, person.фамилия[ 0 ] || person.прозвище[ 0 ] ].compact.join ' '
      end
      log > { name: name }
      log >> '*'*80
      person.фамилия = person.фамилия.join ' '
      person.прозвище = person.прозвище.join ' '
      person.описание = person.описание.join ' '
      person.образ = !person.образ.empty? && person.образ || nil
      people[ name ] = person.to_hash ; end
   people ; end

#date = ARGV.shift
date = Date.parse( ARGV.shift ) rescue Date.today
julian = date.julian
day = julian.day
month = julian.month
people_set = []

Months = [ 'ЯНВАРЯ', 'ФЕВРАЛЯ', 'МАРТА', 'АПРЕЛЯ', 'МАЯ', 'ИЮНЯ',
           'ИЮЛЯ', 'АВГУСТА', 'СЕНТЯБРЯ', 'ОКТЯБРЯ', 'НОЯБРЯ', 'ДЕКАБРЯ' ]
month_str = Months[ month - 1 ]

log * "Search for #{day} #{month_str}\n\n"

# calendar
log * "Parse drevo-info.ru site"
log * ( "*"*80 )

uri = 'http://drevo-info.ru/articles/list/14.html?page='
date_link = 'http://drevo-info.ru' +
(1..4).each do| i |
   drevo_cal = Nokogiri::HTML( open "#{uri}#{i}" )
   li =
   drevo_cal.css( 'li' ).each do| li |
      if li.content == "#{day} #{month_str}" # check 27 НОЯБРЯ
         break li
      end
   end
   if li.is_a? Nokogiri::XML::Element
      break li.css( 'a' ).attr( 'href' ).value
   end
end

if date_link.is_a? String
   drevo_date = Nokogiri::HTML( open date_link )

   seg = drevo_date.css( 'h2' ).each do| h2 |
      if h2.text == 'Память'
         break h2 ; end ; end

   memlist = []
   if !seg.is_a? Array
      #TODO change to seg
      mem = drevo_date.css( '#article ul' )
      mem.css( 'li' ).each do| li |
         if li.content.strip =~ /^\d/
            next ; end
         ml = drevo_person_line li
         memlist |= ml
      end
   end
end

people_set.push( parse_list memlist )


# Azbuka parsing
log * "Parse azbuka.ru site"
log * ( "*"*80 )

date_link = 'http://azbyka.ru/days'
doc = open "#{date_link}/#{date.strftime( "%Y-%m-%d" )}"
azbuka = Nokogiri::HTML doc.read, nil, 'utf-8'

memlist = []
ps = azbuka.css( '#calendar-wrapper .text p' )
ps.to_a.each_index do| i |
   if i == 0
      next ; end
   p = ps[ i ]
   ml = azbuka_p p
   memlist |= ml ; end

people_set.push( parse_list memlist, 1 )


# Pravoslavie.ru parsing
log * "Parse Pravoslavie.ru site"
log * ( "*"*80 )

date_link = 'http://days.pravoslavie.ru/Days'
doc = open "#{date_link}/#{julian.strftime( "%Y%m%d" )}.htm"
prav_ru = Nokogiri::HTML doc.read

prav_people = {}
prav_service = {}
  
trops = prav_ru.css( '.trop' )

def добава куда, име, нечто
   case куда[ име ]
   when Array
      if !куда[ име ].include? нечто
         куда[ име ] << нечто ; end
   when Hash, String
      if куда[ име ].is_a?( Hash ) &&
         куда[ име ].select {| _, нечто | нечто && !нечто.empty? }.empty?
         куда[ име ] = нечто
      elsif куда[ име ] != нечто
         куда[ име ] = [ куда[ име ], нечто ] ; end
   when NilClass
      куда[ име ] = нечто
   end
end

service_tmpl = YAML.load( IO.read 'service.yml' )
services = {}

trops.each do| trop |
   mls = prav_ru_trop trop
   log >> { people: { mls[ 0 ] => mls[ 1 ] } }
   prav_people.merge!( mls[ 0 ] => mls[ 1 ] )
   prav_service[ mls[ 0 ] ] ||= []

   name = "#{mls[ 1 ][ 'служба' ]}.цс_ро.yml"
   value = mls[ 2 ]
   service = services[ name ] || service_tmpl.dup( :recursive )
   log >> { name: name, services: services[ name ] }

   case value[ 0 ]
   when 'тропарь'
      добава service['вечерня']['отпустительно'], 'тропарь', { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
   when 'молитва'
      добава service['вечерня']['отпустительно'], 'молитва', value[ 1 ]
   when 'кондак'
      добава service['утреня']['канон'], 'кондак', { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
   when 'величание'
      добава service['утреня'], 'величание', value[ 1 ]
   end
   services[ name ] = service
end

people_set.push prav_people


# Merge descriptions
log * "Merging the site data"
log * ( "*"*80 )

people = people_set.shift
people_set.each do| current_people |
   current_people.each do| name, person |
      if people.key? name
         log > { Merging: name }
         log >> { P1: people[ name ], P2: person }
         # deep merge
         people[ name ].keys.each do| key |
            people[ name ][ key ] =
            case people[ name ][ key ]
            when Array
               case person[ key ]
               when Array
                  ( people[ name ][ key ] | person.delete( key ) ).uniq
               when NilClass
                  people[ name ][ key ]
               when String
                  if person[ key ].strip.empty?
                     people[ name ][ key ]
                  else
                     ( people[ name ][ key ] | [ person.delete( key ) ] ).uniq ; end
               else
                  ( people[ name ][ key ] | [ person.delete( key ) ] ).uniq ; end
            when NilClass
               case person[ key ]
               when Array
                  person.delete( key )
               when NilClass
               when String
                  if !person[ key ].strip.empty?
                     person.delete( key ) ; end
               else
                  person.delete( key ) ; end
            when String
               if people[ name ][ key ].strip.empty?
                  case person[ key ]
                  when Array
                     person.delete( key )
                  when NilClass
                  when String
                     if !person[ key ].strip.empty?
                        person.delete( key ) ; end
                  else
                     person.delete( key ) ; end
               else
                  case person[ key ]
                  when Array
                     ( [ people[ name ][ key ] ] | person.delete( key ) ).uniq
                  when NilClass
                     people[ name ][ key ]
                  when String
                     if person[ key ].strip.empty?
                        people[ name ][ key ]
                     elsif person[ key ] == people[ name ][ key ]
                        person.delete( key )
                     else
                        ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq ; end
                  else
                     ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq ; end ; end
            else
               case person[ key ]
               when Array
                  ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq
               when NilClass
                  people[ name ][ key ]
               when String
                  if person[ key ].strip.empty?
                     people[ name ][ key ]
                  else
                     ( [ people[ name ][ key ] ] | [ person.delete( key ) ] ).uniq ; end
               else
                  if person[ key ] == people[ name ][ key ]
                     person.delete( key )
                  else
                     ( [ people[ name ][ key ] ] | person.delete( key ) ).uniq ; end ; end ; end
         end
         person.each {| key, value | people[ name ][ key ] }
         log >> people[ name ]
      else
         people[ name ] = person ; end ; end ; end

folder = sprintf "мѣсѧцесловъ/%2i/%2i", month, day
FileUtils.mkdir_p folder
File.open( File.join( folder, 'месяцеслов.ро.yml' ), 'w' ) do| f |
   f.puts people.to_yaml.gsub( /  /, '   ' ).gsub( /'/, '' ).gsub( /\s+$/, '' )
end

services.each do| име, служба |
   име = име.split( '/' )
   FileUtils.mkdir_p File.join( folder, име[ 0 ] )
   File.open( File.join( folder, име[ 0 ], име[ 1 ] ), 'w' ) do| f |
      f.puts служба.to_yaml.gsub( /  /, '   ' ).gsub( / - /, '  - ' ).gsub( /'/, '' ).gsub( /\s+$/, '' )
   end
end

