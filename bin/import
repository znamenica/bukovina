#!/usr/bin/env ruby
#coding: utf-8

require 'yaml'
require 'date'
require 'rdoba'
require 'rdoba/dup'
require 'open-uri'
require 'nokogiri'
require 'hashie'
require 'fileutils'
require 'petrovich'
require 'mechanize'

rdoba :mixin => [ :case ], :log => { :functions => [ :* ], :prefix => [ :function_name, :function_line ] }

Map = {
   /[Сс]вятител/i => 'свт.',
   /[Пп]раведн/i => 'прав.',
   /[Пп]роро/i => 'прор.',
   /[Аа]постол/i => 'ап.',
   /[Мм]учениц/i => 'мц.',
   /[Мм]ученик/i => 'мч.',
   /[Сс]вященномучен/i => 'сщмч.',
   /[Пп]реподобномучен/i => 'прмч.',
   /[Пп]реподобн/ => 'прп.',
   /[Бб]бессребрен/i => 'бср.',
   /[Сс]вято/i => 'прав.',
   /[Бб]лаженн/i => 'блж.',
   /[Пп]реподобносповедни/i => 'присп.',
   /[Ии]споведни/i => 'исп.',
   /[Мм]итр\./i => 'святитель',
   /[Аа]рхиеп\./i => 'святитель',
   /[Ее]п\./i => 'святитель',
   /[Сс]вящ\./i => 'священник',
   /Свтт?\./i => 'свт.',
   /Правв?\./i => 'прав.',
   /Прорр?\./i => 'прор.',
   /Апп?\./i => 'ап.',
   /Мцц?\./i => 'мц.',
   /Мчч?\./i => 'мч.',
   /Сщмчч?\./i => 'сщмч.',
   /Прмчч?\./i => 'прмч.',
   /Прпп?\./ => 'прп.',
   /Бсрр?\./i => 'бср.',
   /Свв?\./i => 'прав.',
   /Блжж?\./i => 'блж.',
   /Приспп?\./i => 'присп.',
   /Испп?\./i => 'исп.',
}

Case = [
   /^Пресвитер/,
]

def ократчити_склад склад
   if склад =~ /^[А-ЯЁ]/
      склад = склад[ 0 ] << склад[ 1..-1 ].downcase ; end

   замена = Map.select {| к, _ | склад =~ к }
   if !замена.empty?
      замена = замена.to_a.last.last.dup
   else
      замена = Case.select {| к | склад =~ к }
      if !замена.empty?
         замена = склад.downcase! ; end ; end

   log - ( замена.empty? && склад || замена )
end

def общя_замена словеса
   словеса.split( /\s+/ ).map {| склад | ократчити_склад склад}.join ' ' ; end

def добава куда, име, нечто
   case куда[ име ]
   when Array
      if !куда[ име ].include? нечто
         куда[ име ] << нечто ; end
   when Hash, String
      if куда[ име ].is_a?( Hash ) &&
         куда[ име ].select {| _, нечто | нечто && !нечто.empty? }.empty?
         куда[ име ] = нечто
      elsif куда[ име ] != нечто
         куда[ име ] = [ куда[ име ], нечто ] ; end
   when NilClass
      куда[ име ] = нечто
   end
end

def добавить_память памяти, person
   память = памяти.map do| память |
      имена = выделить_имя память
      имена_новы = выделить_имя person
      имена_общи = имена & имена_новы
      имена_общи.size >= 2 && [ имена_общи.size, память ] || nil
   end.compact.sort do| x, y |
      x <=> y
   end.last[ 1 ] rescue nil

   if память
      log > { 'Добавлена память' => person }
      имена_новы = выделить_имя person
      имена_общи = ( выделить_имя память ) & имена_новы
      память.прозвище = ( имена_новы - имена_общи ) + память.прозвище
      память.прозвище << ( person.прозвище - ( память.прозвище & person.прозвище ) )
      память.фамилия << ( person.фамилия - ( память.фамилия & person.фамилия ) )
      память.описание << ( person.описание - ( память.описание & person.описание ) )
      память.чин = ( память.чин.split(',') + ( person.чин.split(',') - ( память.чин.split(',') & person.чин.split(',') ) ) ).join( ',' ) rescue память.чин || person.чин
      память.год = ( память.год.split(',') + ( person.год.split(',') - ( память.год.split(',') & person.год.split(',') ) ) ).join( ',' ) rescue память.год || person.год
      память.собор = ( память.собор.split(',') + ( person.собор.split(',') - ( память.собор.split(',') & person.собор.split(',') ) ) ).join( ',' ) rescue память.собор || person.собор
      if !память.вики && person.вики
         память.вики = person.вики ; end
      if !память.бытие && person.бытие
         память.бытие = person.бытие ; end
      if память.отечник && person.отечник
         память.отечник = person.отечник ; end
      память.образ << ( person.образ - ( память.образ & person.образ ) )
      log > { 'Суплетена память' => память }
   else
      памяти << person
      log > { 'Добавлена память' => person } ; end

   new_person ; end

def обращение память, склад, вид
   род =
   if память.чин =~ /мц|обр/
      :female
   elsif !память.чин
      :androgynous
   else
      :male ; end
   петро = Petrovich.new род
   if вид == :имя
      петро.firstname склад, :nominative, :genitive
   else
      петро.lastname склад, :nominative, :genitive ; end ; end

def search_for services, name
   service = services[ name ]
   if service
      return service ; end
   names = name.split( '/' )[ 0 ].split /\s+/

   if names.size > 1
      services.each do| key, value |
         key = key.split( '/' )[ 0 ]
         if names.reject {| n | key.include? n }.empty?
            return value ; end ; end ; end
   nil ; end

def выделить_имя память
   [ память.имя, память.прозвище,
     память.фамилия, память.описание ].flatten.compact.select do| имя |
      имя =~ /^[А-ЯЁ]/ ; end ; end

def assign_trops trops, памяти, services
   service_tmpl = YAML.load( IO.read 'service.yml' )
   trops.each do| trop |
      ( names, glas, text, cases ) = yield trop
      mls = parse_trop( памяти, names, glas, text, cases ) do | чин, names |
         log > { trop_names: names }
         краткъ = ократчити_склад( чин )
         краткъ = краткъ =~ /(.*)\.$/ && $1 || краткъ
         log > { чин: краткъ }
         case names.size
         when 0
            новы = памяти.select do| память |
               память.чин == краткъ ; end
            новы.size > 0 && новы.last || nil
         else
            весы = 
            памяти.map do| память |
            p память
               вес = ( выделить_имя( память ) & names ).size * 2
               if память.чин && память.чин == краткъ
                  вес += 1 ; end
               [ вес, память ] ; end.sort do| x, y |
                  x[ 0 ] <=> y[ 0 ] ; end
            log >> { весы: весы }
            память = весы.last[ 1 ] rescue nil

            if память
               общи_имена = выделить_имя( память ) & names
               имена = names - общи_имена
               память.прозвище = имена + память.прозвище ; end

            память ; end ; end

      log >> { память: mls }

      name = "#{mls[ 1 ]}.цс_ро.yml"
      value = mls[ 2 ]
      service = search_for( services, name ) || service_tmpl.dup( :recursive )
      log >> { name: name, services: services[ name ] }
   
      case value[ 0 ]
      when 'тропарь'
         добава service['вечерня']['отпустительно'], 'тропарь',
                { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
      when 'молитва'
         добава service['вечерня']['отпустительно'], 'молитва',
                value[ 2 ]
      when 'кондак'
         добава service['утреня']['канон'], 'кондак',
                { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
      when 'величание'
         добава service['утреня'], 'величание',
                value[ 2 ]
      end
      services[ name ] = service
   end
end

def parse_trop памяти, names, glas, text, cases
   if names[ 0 ] =~ /[Ии]н/
      names.shift ; end
   kind = names.shift.downcase

   чин = names[ 0 ] =~ /^[а-яё]/ && names.shift || ''

   род =
   if чин =~ /мученицы|преподобной|праведной/ || names[ 0 ] =~ /Божией/i
      :female
   else
      :male ; end
   petro = Petrovich.new род

   fname = ''
   names =
   names.select do| name |
      name =~ /[А-ЯЁ]/ &&
      name !~ /Божией|Матери|Ее|Пресвят|Богородице|Ея|Свято|Крещен|Священномучени/
   end.map do| name |
      def apply_cases petro, method, cases, name
         cases = cases.is_a?( Array ) && cases || [ cases ]
         new =
         cases.each do| c |
            new = petro.send method, name, :nominative, c
            if new != name
               break new ; end ; end
         new.is_a?( Array ) && name || new ; end

      name.gsub! /[«»]+/, ''
      if fname.empty?
         fname = apply_cases petro, :firstname, cases, name
      else
         apply_cases petro, :lastname, cases, name ; end ; end

   память = yield чин, names
   log > { 'выбрана память' => память }
   names = ( память && выделить_имя( память ) || names )[ 0, 2 ]
   log > { 'выбраны имена' => names }
   service = ''
   name = names.join ' '

   if !names.empty?
      fservice = petro.firstname names.shift, :dative
      if !names.empty?
         lservice = petro.lastname names.last, :dative ; end
      service = [ fservice, lservice, 'служба' ].join ' ' ; end

   if !память
      память = new_person
      память.имя = names.shift || ''
      память.прозвище = names
      добавить_память памяти, память
   end

   служба = "#{name}/#{service}"
   case память.служба
   when NilClass
      память.служба = служба
   when String
      if память.служба != служба
         память.служба = [ память.служба, служба ] ; end
   when Array
      if !память.служба.include? служба
         память.служба << служба ; end ; end
   
   [ name, служба, [ kind, glas, text ] ] ; end

def заверка_прозвища person, name
   if !person.прозвище.include?( name ) && !person.фамилия.include?( name ) &&
      !person.описание.include?( name )
      person.прозвище = ( person.прозвище.split( ' ' ) << name ).join ' '
      end ; end

def new_person
   person = Hashie::Mash.new
   person.имя = ''
   person.прозвище = []
   person.фамилия = []
   person.описание = []
   person.чин = nil
   person.год = nil
   person.собор = []
   person.служба = nil
   person.вики = nil
   person.бытие = nil
   person.отечник = nil
   person.образ = []
   person ; end

def parse_tokens памяти, tokens, store_name = 'вики'
   person = new_person

   nocase = false
   склад = nil
   tokens.each do| t |
      log > { склад: t }
      case t
      when /Nocase/
         nocase = true
      when /Case/
         nocase = false
      when /^http:\/\/(.*)/
         if $1.empty?
            log > "Отмена ссылки"
            next
         else
            log > { Ссылка: t } ; end

         if t =~ /otechnik/
            person.отечник = t
         else
            person[ store_name ] = t ; end
      when /^и$/
         log > "Разделитель имен"
         склад = nil
         person = добавить_память памяти, person
      when /^([а-яё]+)\.$/
         чин = $1
         log > { Чин: чин }
         person.чин = чин
      when /^[А-ЯЁ]/
         if person.имя.empty?
            имя = nocase && t || обращение( person, t, :имя )
            log > { Имя: имя }
            person.имя = имя
         elsif склад == :скобы
            собор = t.split( ',' ).map do| s |
               s = s.strip.downcase
               s =~ /(.*)\.\)?$/ && $1.to_s || s ; end
            log > { Собор: собор }
            person.собор = собор
         else
            имя = nocase && t || обращение( person, t, :фамилия )
            log > { Прозвище: имя }
            person.прозвище.unshift имя
         end
      when /^[а-яё\d]/
         имя = nocase && t || обращение( person, t, :фамилия )
         log > { Описание: имя }
         person.прозвище << имя
      when /^\(([А-ЯЁ][а-яё\-]+)\)/
         фамилия = nocase && t || обращение( person, $1, :фамилия )
         log > { Фамилия: фамилия }
         person.фамилия << фамилия
      when /^\(([\dIVX\.а-яё]+)/
         год = $1
         log > { Год: год }
         person.год = год
         склад = :скобы
      when /^\(([А-ЯЁ][\.,а-яё]+)\)/
         собор = $1.split( ',' ).map{|s|s.strip.downcase}
         log > { Собор: собор }
         person.собор = собор
      when /(.*)\)$/
         tt = $1
         log > { Подсклад: tt }
         case склад
         when :скобы
            person.год << ' ' << tt
            склад = nil
         else
            if tt =~ /^[\dIVX\.а-яё]+/
               if person.год
                  person.год << ',' << tt
               else
                  person.год = tt ; end
            else
               log % { 'Нерешённый подсклад' => t }
               $stderr.puts "Нерешённый подсклад #{tt}" ; end ; end
      when ''
         log > "Пробел"
      else
         log % { 'Нерешённый склад' => t }
         $stderr.puts "Нерешённый склад #{t}" ; end ; end

   # set чин
   чин = nil
   памяти.each do| person |
      if person.чин
         if person.чин[ -1 ] == person.чин[ -2 ]
            чин = person.чин[ 0..-2 ]
            person.чин = чин
         else
            чин = person.чин ; end
      else
         person.чин = чин ; end ; end

   # set год
   год = nil
   памяти.reverse.each do| person |
      if person.год
         год = person.год
      else
         person.год = год ; end ; end ; end

def е_исключение слово
   Исключения = [
      /ого[^А-ЯЁа-яё]*$/,
      /его[^А-ЯЁа-яё]*$/,
      /ой[^А-ЯЁа-яё]*$/,
   ]

   !Исключения.select {|s| слово =~ s }.empty?
end

def tokenize_line li, base
   # expanding groups
   lis = li.children.to_a.map do| li_e |
      if li_e.is_a?( Nokogiri::XML::Element ) && li_e.attr( 'href' ) =~ /group/
         url = li_e.attr( 'href' )
         uri = url =~ /^http/ && url || ( base + url )
         azbuka_group = Nokogiri::HTML( open( uri ), nil, 'utf-8' )
         ary = [ Nokogiri::XML::Text.new( 'Nocase', li_e ) ]
         ary.concat azbuka_group.css( "#featured .cont h1" ).children.to_a
         text = li_e.content
         if text =~ /(\(.*[\dIVX]+.*\))/
            ary << Nokogiri::XML::Text.new( $1.to_s, li_e ) ; end
         ary << Nokogiri::XML::Text.new( 'Case', li_e )
      else
         li_e ; end ; end.flatten

   current_uri = 'http://'
   tokens = [ current_uri ]
   lis.each do| li_e |
      if li_e.is_a? Nokogiri::XML::Comment
         next ; end
      text = li_e.content.gsub( /[<!«»:]|--/, '' ).gsub( / +/, ' ' ).strip #NBSP to Space here
      log * ( '&'*80 )
      log >> { букы: text }
      uri =
      if li_e.is_a?( Nokogiri::XML::Element ) &&
         li_e.name == 'a' && text !~ /^(?:[\dIVX]+|[^\(\),;А-Я]+[\dIVX]+)$/ &&
         li_e.attr( 'href' ) !~ /\/(find|p-znaki|p-san|p-tip)/
         log >> "Ссылка"
         url = li_e.attr( 'href' )
         url =~ /^http/ && url || ( base + url )
      else
         'http://' ; end

      t = text.split /\s+/, -1
      if tokens.size > 0 && !tokens.last.empty? &&
         tokens.last =~ /^[А-ЯЁа-яё]+$/ && tokens.last != 'и' &&
         uri =~ /^http:\/\/$/ &&
         !( t.empty? || t[ 0 ].empty? || t[ 0 ] == 'и' || t[ 0 ] !~ /^[А-ЯЁа-яё]+$/ )
         log >> { "Прибавлена вещка" => t[ 0 ] }
         tokens.last << t.shift ; end

      if current_uri != uri
         current_uri = uri
         log >> { "Добавлена ссылка" => uri }
         tokens << uri ; end

      log >> { "Добавлен набор" => t }
      tokens.concat t ; end

   log >> { tokens: tokens }
   tokens.map! {| t | ократчити_склад t }
   tokens.map!.with_index do| t, i |
      под = []
      if t =~ /(.*)[,;]$/
         t = $1
         tokens[ (i + 1)..-1 ].each do| tt |
            иск = tt =~ /\.\)?$/ || е_исключение( tt )
            if tt =~ /^[А-ЯЁ]/ && !иск || t.empty?
               под << t << 'и'
               t = nil               
               break
            elsif tt =~ /^[а-яё].*[^.]?$/ || иск
               break ; end ; end ; end
      if t =~ /^[,;](.*)/
         t = $1
         tokens[ 0, i - 1 ].each do| tt |
            if tt =~ /^[А-ЯЁ]/ && tt !~ /\.\)?$/
               под << 'и'
               break
            elsif tt =~ /^[а-яё].*[^.]$/ || tt =~ /\.\)?$/
               break ; end ; end ; end
      if t
         под << t ; end
      под ; end

   log - ( tokens << 'и' ).flatten ; end

def parse_list list
   def detect_uniq_name память
      url =
      if память.вики
         log >> { вики: память.вики }
         память.вики         
      elsif память.бытие
         log >> { бытие: память.бытие }
         память.бытие
      end
      память_doc = Nokogiri::HTML( ( open url), nil, 'utf-8' )
      name = память_doc.css( 'h1' ).text
      name = общя_замена name.strip
      parts = name.split( /\s+/ ).select {| v | v =~ /^[А-ЯЁ]/ }

      parts =
      if память.вики && parts.size == 3
         [ parts[ 1 ], parts[ 0 ] ]
      else
         parts[ 0, 2 ] ; end
      new = parts.map {| p | p.gsub( /[,«»\d\)\(]+/, '' ) }
      new.grep( /[А-ЯЁ]/ ) && new || name.split( /\s+/ ) ; end

   people = {}
   list.each do| память |
      log >> { память: память }
      name1 = []
      if !память.имя.empty?
         вторки = [ память.фамилия, память.прозвище ].flatten.compact
         вторка = вторки.select {| имя | имя =~ /^[А-ЯЁ]/ }[ 0 ]
         name1 = [ память.имя, вторка ].compact ; end
      log >> { 'name 1' => name1 }

      name2 = []
      if память.бытие || память.вики
         name2 = detect_uniq_name память ; end
      log >> { 'name 2' => name2 }
      log >> '*'*80

      память.фамилия = память.фамилия.select{|a|!a.empty?}.join( ' ' ).strip
      память.прозвище = память.прозвище.select{|a|!a.empty?}.join( ' ' ).strip
      память.описание = память.описание.select{|a|!a.empty?}.join( ' ' ).strip
      if память.год =~ /19(\d\d)/
         num = $1.to_i 
         if num >= 17 && num <= 48
            память.собор << 'нмр' ; end ; end
      память.собор = память.собор.select{|a|!a.empty?}.join( ',' ).strip
      память.образ = память.образ.select{|a|!a.empty?}

      name = ( name2.size <= name1.size && name1 || name2 ).join ' '
      if name.empty?
         name = !память.прозвище.empty? && память.прозвище || память.описание
         end
      log > { 'name selected' => name }

      if name
         заверка_прозвища память, ( name.split( ' ' ).last || '' ) ; end
      память = память.to_hash.reject! {| _, з | з.nil? || з.empty? }
      if people.key? name
         i = 0
         while people.key? "#{name}-#{i}"
            i += 1 ; end
         people[ "#{name}-#{i}" ] = память
      else
         people[ name ] = память ; end ; end
   people ; end

#date = ARGV.shift
date = Date.parse( ARGV.shift ) rescue Date.today
julian = date.julian
day = julian.day
month = julian.month
services = {}

Months = [ 'ЯНВАРЯ', 'ФЕВРАЛЯ', 'МАРТА', 'АПРЕЛЯ', 'МАЯ', 'ИЮНЯ',
           'ИЮЛЯ', 'АВГУСТА', 'СЕНТЯБРЯ', 'ОКТЯБРЯ', 'НОЯБРЯ', 'ДЕКАБРЯ' ]
month_str = Months[ month - 1 ]

log * "Search for #{day} #{month_str}\n\n"

# calendar
log * "Parse drevo-info.ru site"
log * ( "*"*80 )

uri = 'http://drevo-info.ru/articles/list/14.html?page='
date_link = 'http://drevo-info.ru' +
(1..4).each do| i |
   drevo_cal = Nokogiri::HTML( open "#{uri}#{i}" )
   li =
   drevo_cal.css( 'li' ).each do| li |
      if li.content == "#{day} #{month_str}" # check 27 НОЯБРЯ
         break li
      end
   end
   if li.is_a? Nokogiri::XML::Element
      break li.css( 'a' ).attr( 'href' ).value
   end
end

memlist = []
tokens = []
if date_link.is_a? String
   drevo_date = Nokogiri::HTML( open date_link )

   seg = drevo_date.css( 'h2' ).each do| h2 |
      if h2.text == 'Память'
         break h2 ; end ; end

   if !seg.is_a? Array
      #TODO change to seg
      mem = drevo_date.css( '#article ul' )
      mem.css( 'li' ).each do| li |
         if li.content.strip =~ /^\d/
            next ; end
         tokens.concat( tokenize_line li, 'http://drevo-info.ru' )
      end
   end
end

parse_tokens memlist, tokens

# Pravoslavie.ru parsing
log * "Parse Pravoslavie.ru site"
log * ( "*"*80 )

date_link = 'http://days.pravoslavie.ru/Days'
doc = open "#{date_link}/#{julian.strftime( "%Y%m%d" )}.htm"
prav_ru = Nokogiri::HTML doc.read

assign_trops( ( prav_ru.css '.trop' ),
              memlist, services ) do| trop |
   names = trop.css( '.trop_title' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.trop_glas' ).inner_text.strip
   text = trop.css( '.trop_text' ).inner_text.strip
   log * ( "#"*80 )
   log >> { names: names }
   [ names, glas, text, :genitive ] ; end


# Azbuka parsing
log * "Parse azbuka.ru site"
log * ( "*"*80 )

tokens = []
date_link = 'http://azbyka.ru/days'
doc = open "#{date_link}/#{date.strftime( "%Y-%m-%d" )}"
azbuka = Nokogiri::HTML doc.read, nil, 'utf-8'

ps = azbuka.css( '#calendar-wrapper .text p' )
ps.to_a.each_index do| i |
   if i == 0
      next ; end
   p = ps[ i ]
   tokens.concat( tokenize_line p, nil ) ; end

parse_tokens memlist, tokens, 'бытие'

assign_trops( ( azbuka.css '.taks_block .taks_content' ),
              memlist, services ) do| trop |
   names = trop.css( 'h3' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.glas' ).inner_text.strip rescue ''
   text = trop.css( 'div' ).inner_text.strip
   log > ( "#"*80 )
   log >> { names: names }
   [ names, glas, text, [ :dative, :genitive ] ] ; end

# Merge people descriptions
log * "Merging the site data"
log * ( "*"*80 )

# pravicon.com search

log * "Pravicon.ru search"
log * ( "*"*80 )

agent = Mechanize.new
#agent.user_agent_alias = 'Windows IE 9'

memlist.each do| память |
   log >> { память: память }
   names = выделить_имя память
   if names.empty?
      next ; end

   log > { name: names }
   page = agent.get 'http://pravicon.com/'
   f = page.forms.first
   f.search = names.shift
   f.selectdb = память.чин == 'обр' && 'b' || 's'
   log >> { form: f }
   begin
      content = f.submit( f.buttons.last ).content
      doc = Nokogiri::HTML content
   rescue
      next
   end

   uris = doc.css( '#content a' ).select do| a |
      log >> { 'match for' => a.content }
      names.reject {| name | a.content.include? name }.empty?
   end.map do| a |
      ( 'http://pravicon.com' + a.attr( 'href' ) )
   end

   if names.empty? && uris.size > 1
      next ; end
   case uris.size
   when 0
   when 1
      память.образ = [ uris.last ]
      if !память.бытие
         doc = Nokogiri::HTML( open uris.last )
         a = doc.css( ".spoiler a" )[ 0 ]
         if a
            память.бытие = 'http://pravicon.com' + a.attr( 'href' ) ; end ; end
   else
      память.образ = uris ; end ; end

people = parse_list memlist

folder = sprintf "мѣсѧцесловъ/%02i/%02i", month, day
FileUtils.mkdir_p folder
File.open( File.join( folder, 'месяцеслов.ро.yml' ), 'w' ) do| f |
   f.puts people.to_yaml.gsub( /  /, '   ' ).gsub( /['\[\]]+/, '' ).gsub( /\s+$/, '' )
end

services.each do| име, служба |
   име = име.split( '/' )
   FileUtils.mkdir_p File.join( folder, име[ 0 ] )
   File.open( File.join( folder, име[ 0 ], име[ 1 ].to_s ), 'w' ) do| f |
      f.puts служба.to_yaml.gsub( /  /, '   ' ).gsub( / - /, '  - ' ).gsub( /'/, '' ).gsub( /\s+$/, '' )
   end
end

