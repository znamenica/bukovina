#!/usr/bin/env ruby
#coding: utf-8

require 'yaml'
require 'date'
require 'rdoba'
require 'rdoba/dup'
require 'open-uri'
require 'nokogiri'
require 'hashie'
require 'fileutils'
require 'petrovich'
require 'mechanize'

rdoba :mixin => [ :case ], :log => { :functions => [ :* ], :prefix => [ :function_name, :function_line ] }

Map = {
   /[Сс]вятител|Свтт?\./i => 'свт.',
   /[Пп]раведн|Правв?\./i => 'прав.',
   /[Пп]роро|Прорр?\./i => 'прор.',
   /[Аа]постол|Апп?\./i => 'ап.',
   /[Сс]вященномучен|Сщмчч?\./i => 'сщмч.',
   /[Пп]реподобносповедни|Приспп?\./i => 'присп.',
   /[Пп]реподобномучен|Прмчч?\./i => 'прмч.',
   /[Мм]учениц|Мцц?\./i => 'мц.',
   /[Мм]ученик|Мчч?\./i => 'мч.',
   /[Пп]реподобн|Прпп?\./ => 'прп.',
   /[Бб]бессребрен|Бсрр?\./i => 'бср.',
   /[Сс]вято|Свв?\./i => 'прав.',
   /[Бб]лаженн|Блжж?\./i => 'блж.',
   /[Ии]споведни|Испп?\./i => 'исп.',
   /[Бб]лаговерн|Блгв?\./i => 'блгв.',
   /[Пп]атр\.?/i => 'первосвятитель',
   /[Пп]атр\.?/i => 'первосвятитель',
   /[Мм]итр\.?/i => 'святитель',
   /[Аа]рхиеп|[Ее]п\.?/i => 'святитель',
   /[Сс]вящ\.?|[Пп]ресвит/i => 'священник',
   /[Кк]н\.?/i => 'князь',
   /[Ии]гум\.?/i => 'игумен',
   /[Ии]ером\.?/i => 'иеромонах',
   /[Пп]опразднство/ => 'попразднство',
   /[Пп]рославление/ => 'прославление',
   /([А-ЯЁ][а-яё]+[оае]го)\.$/i => nil,
   /([А-ЯЁ][а-яё]+(?:ла|лы))\.$/i => nil,
}

Case = [
   /^Пресвитер/,
]

def ократчити_склад склад
   if склад =~ /^[А-ЯЁ]/
      склад = склад[ 0 ] << склад[ 1..-1 ].downcase ; end

   замены = Map.map do| к, з |
      ( попад = к.match( склад ) ) && [ з, попад ] || nil
   end.compact

   if !замены.empty?
      замена = замены.to_a.first.first
      if !замена
         замена = замены.to_a.first.last.to_a.last
      end
   else
      замена = Case.select {| к | склад =~ к }
      if !замена.empty?
         замена = склад.downcase! ; end ; end

   log - ( замена.empty? && склад || замена )
end

def общя_замена словеса
   словеса.split( /\s+/ ).map {| склад | ократчити_склад склад}.join ' ' ; end

def добава куда, име, нечто
   case куда[ име ]
   when Array
      if !куда[ име ].include? нечто
         куда[ име ] << нечто ; end
   when Hash, String
      if куда[ име ].is_a?( Hash ) &&
         куда[ име ].select {| _, нечто | нечто && !нечто.empty? }.empty?
         куда[ име ] = нечто
      elsif куда[ име ] != нечто
         куда[ име ] = [ куда[ име ], нечто ] ; end
   when NilClass
      куда[ име ] = нечто
   end
end

def detect_uniq_name память
   url =
   if память.вики
      log >> { вики: память.вики }
      память.вики         
   elsif память.бытие
      log >> { бытие: память.бытие }
      память.бытие
   end
   память_doc = Nokogiri::HTML( ( open url), nil, 'utf-8' )
   name = память_doc.css( 'h1' ).text
   name = общя_замена name.strip
   parts = name.split( /\s+/ ).select {| v | v =~ /^[А-ЯЁ]/ }

   parts =
   if память.вики && parts.size == 3
      [ parts[ 1 ], parts[ 0 ] ]
   else
      parts[ 0, 2 ] ; end
   new = parts.map {| p | p.gsub( /[,«»\d\)\(]+/, '' ) }
   new.grep( /[А-ЯЁ]/ ) && new || name.split( /\s+/ ) ; end

def усечь_поле присуще, *новы
   усечены = []
   новы.each do| ново |
      усечены << ново - ( присуще & ново )
   end
   усечены
end

def поплести_память память, person
   log + { память: память, нова_память: person }
   присуще = обще_имя память
   фамилия, прозвище = усечь_поле присуще, person.фамилия, person.прозвище
   память.фамилия = фамилия + память.фамилия
   память.прозвище = прозвище + память.прозвище
   ( память.описание << ( person.описание - ( память.описание & person.описание ) ) ).uniq!
   память.чин = ( память.чин.split(',') + ( person.чин.split(',') - ( память.чин.split(',') & person.чин.split(',') ) ) ).join( ',' ) rescue память.чин || person.чин
   память.событие.год = ( память.событие.год.split(',') + ( person.событие.год.split(',') - ( память.событие.год.split(',') & person.событие.год.split(',') ) ) ).join( ',' ) rescue память.событие.год || person.событие.год
   память.собор = память.собор + ( person.собор - ( память.собор & person.собор ) )
   if !память.вики && person.вики
      память.вики = person.вики ; end
   if !память.бытие && person.бытие
      память.бытие = person.бытие ; end
   if память.отечник && person.отечник
      память.отечник = person.отечник ; end
   память.образ.concat усечь_поле( память.образ, person.образ ).last
   log > { 'Суплетена память' => память } ; end

def добавить_память памяти, person
   log + { person: person }

   памятие = памяти.map do| память |
      имена = выделить_имя память
      имена_новы = выделить_имя person
      имена_общи = имена & имена_новы
      вес = имена_общи.size
      if имена.size < 2 && имена_новы.size < 2 && память.чин == person.чин
         вес += 1 ; end
      вес >= 2 && [ вес, память ] || nil
   end.compact.sort do| x, y |
      x[ 0 ] <=> y[ 0 ]
   end
   log >> { памятие: памятие }

   if person.бытие || person.вики
      name = detect_uniq_name person
      имена, = усечь_поле( ( выделить_имя person ), name )
      person.прозвище = имена + person.прозвище ; end

   память = памятие.last[ 1 ] rescue nil
   if память
      поплести_память память, person
   else
      памяти << person
      log > { 'Добавлена память' => person } ; end
   new_person ; end

def обращение память, склад, вид
   рода =
   if память.чин =~ /мц|обр/
      [ :female ]
   elsif !память.чин
      [ :androgynous, :male, :female ]
   else
      [ :male, :female, :androgynous ] ; end

   имя =
   рода.each do| род |
      петро = Petrovich.new род
      имя =
      if вид == :имя
         петро.firstname склад, :nominative, :genitive
      else
         петро.lastname склад, :nominative, :genitive ; end
      if имя != склад
         break имя ; end ; end
   имя.is_a?( Array ) && склад || имя ; end

def search_for services, name
   service = services[ name ]
   if service
      return service ; end
   names = name.split( '/' )[ 0 ].split /\s+/

   if names.size > 1
      services.each do| key, value |
         key = key.split( '/' )[ 0 ]
         if names.reject {| n | key.include? n }.empty?
            return value ; end ; end ; end
   nil ; end

def обще_имя память
   [ память.имя, память.прозвище,
     память.фамилия, память.описание ].flatten.compact.uniq ; end

def выделить_имя память
   обще_имя( память ).select do| имя |
      имя =~ /^[А-ЯЁ]/ ; end ; end

def assign_trops trops, памяти, services
   service_tmpl = YAML.load( IO.read 'service.yml' )
   trops.each do| trop |
      ( names, glas, text, cases ) = yield trop
      mls = parse_trop( памяти, names, glas, text, cases ) do | чин, names |
         log > { 'имена тропаря' => names }
         краткъ = ократчити_склад( чин )
         краткъ = краткъ =~ /(.*)\.$/ && $1 || краткъ
         log > { чин: краткъ }
         case names.size
         when 0
            новы = памяти.select do| _, память |
               память.чин == краткъ ; end
            новы.size > 0 && новы.last || nil
         else
            весы = 
            памяти.map do| _, память |
               вес = ( выделить_имя( память ) & names ).size * 2
               if память.чин && память.чин == краткъ
                  вес += 1 ; end
               [ вес, память ] ; end.sort do| x, y |
                  x[ 0 ] <=> y[ 0 ] ; end
            log >> { весы: весы }
            память = весы.last && весы.last[ 0 ] > 1 && весы.last[ 1 ] || nil

            log > { память: память }
            if память
               имена = names - ( выделить_имя( память ) & names )
               память.прозвище = имена + память.прозвище ; end

            память ; end ; end

      log >> { память: mls }

      name = "#{mls[ 1 ]}.цс_ро.yml"
      value = mls[ 2 ]
      service = search_for( services, name ) || service_tmpl.dup( :recursive )
      log >> { name: name, services: services[ name ] }
   
      case value[ 0 ]
      when 'тропарь'
         добава service['вечерня']['отпустительно'], 'тропарь',
                { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
      when 'молитва'
         добава service['вечерня']['отпустительно'], 'молитва',
                value[ 2 ]
      when 'кондак'
         добава service['утреня']['канон'], 'кондак',
                { 'глас' => value[ 1 ], 'текст' => value[ 2 ] }
      when 'величание'
         добава service['утреня'], 'величание',
                value[ 2 ]
      end
      services[ name ] = service
   end
end

def parse_trop памяти, имена, glas, text, cases
   log + { имена: имена, glas: glas, text: text, cases: cases }
   if имена[ 0 ] =~ /[Ии]н/
      имена.shift ; end
   names = имена.map {|o| o !~ /[Тт]ропарь|[Кк]ондак|[Мм]олитва|[Вв]еличание/ && o || nil }
   kind = ( имена - names ).last.downcase

   чин = names[ 0 ] =~ /^[а-яё]/ && names.shift || ''

   род =
   if чин =~ /мученицы|преподобной|праведной/ || names[ 0 ] =~ /Божией/i
      :female
   else
      :male ; end
   petro = Petrovich.new род

   fname = ''
   names =
   names.select do| name |
      name =~ /[А-ЯЁ]/ &&
      name !~ /Божией|Матери|Ее|Пресвят|Богородице|Ея|Свято|Крещен|Священномучени/
   end.map do| name |
      def apply_cases petro, method, cases, name
         log + { petro: petro, method: method, cases: cases, name: name }
         cases = cases.is_a?( Array ) && cases || [ cases ]
         new =
         cases.each do| c |
            new = petro.send method, name, :nominative, c
            if new != name
               break new ; end ; end
         log - ( new.is_a?( Array ) && name || new ); end

      name.gsub! /[«»]+/, ''
      if fname.empty?
         fname = apply_cases petro, :firstname, cases, name
      else
         apply_cases petro, :lastname, cases, name ; end ; end

   память = yield чин, names
   log > { 'выбрана память' => память }
   names = ( память && выделить_имя( память ) || names )[ 0, 2 ]
   log > { 'выбраны имена' => names }
   service = ''
   имя = names.join ' '

   if !память
      память = new_person
      память.имя = names.shift || name
      память.прозвище = names
      $stderr.print "#{памяти.keys.size}. #{память.имя}\n? "
      имя = $stdin.gets.strip
      имя = имя.empty? && память.имя || имя
      if памяти[ имя ]
         поплести_память памяти[ имя ], память
      else
         памяти[ имя ] = память ; end
      память = памяти[ имя ]

      if память.чин =~ /мц/
         род = :female ; end
      $stderr.print "#{род}:\n? "
      род1 = $stdin.gets.strip
      if !род1.empty?
         род = /^m/ =~ род1 && :male || :female ; end
      petro = Petrovich.new род
   else
      имя = памяти.key память
   end

   names = имя.split ' '
   fservice = petro.firstname names.shift, :dative
   if !names.empty?
      lservice = petro.lastname names.last, :dative ; end
   служба = File.join( имя, [ fservice, lservice, 'служба' ].join( ' ' ) )

   if память.служба
      служба = память.служба
   else
      память.служба = служба
   end
   
   [ имя, служба, [ kind, glas, text ] ] ; end

def заверка_прозвища person, name
   if !person.прозвище.include?( name ) && !person.фамилия.include?( name ) &&
      !person.описание.include?( name )
      person.прозвище = ( person.прозвище.split( ' ' ) << name ).join ' '
      end ; end

def new_person
   event = Hashie::Mash.new
   event.год = []
   event.дата = nil
   event.описание = nil
   person = Hashie::Mash.new
   person.имя = ''
   person.прозвище = []
   person.фамилия = []
   person.описание = []
   person.чин = nil
   person.собор = []
   person.служба = nil
   person.вики = nil
   person.бытие = nil
   person.отечник = nil
   person.образ = []
   person.событие = event
   person ; end

def parse_tokens памяти, tokens, store_name = 'вики'
   person = new_person

   nocase = false
   line = []
   склад = nil
   tokens.each do| t |
      log > { склад => t, 'вид склада' => склад }
      if склад == :скобы
         case t
         when '', 'и', '.'
         when ')'
            if !line.empty?
               год = line.join( ' ' ).gsub( / ([-\/]) /, '\1' )
               log > { Год: год }
               person.событие.год << год
               line = [] ; end
            склад = nil
         when /^([А-ЯЁ][а-яё]+)\./
            собор = $1.to_s.downcase
            log > { Собор: собор }
            person.собор << собор
         when /^([А-ЯЁ][а-яё\-]+)/
            фамилия = nocase && t || обращение( person, $1, :фамилия )
            log > { Фамилия: фамилия }
            person.фамилия << фамилия
         when /^[а-яёА-ЯЁ\dIVX\-\/]/
            line << t
         else
            log % { 'Нерешённый склад' => t }
            $stderr.puts "Нерешённый склад #{t.inspect}" ; end
      else
         case t
         when /Nocase/
            nocase = true
         when /Case/
            nocase = false
         when /^http:\/\/(.*)/
            if $1.empty?
               log > "Отмена ссылки"
               next
            else
               log > { Ссылка: t } ; end
   
            if t =~ /otechnik/
               person.отечник = t
            else
               person[ store_name ] = t ; end
         when /^и$/
            log > "Разделитель имен"
            склад = nil
            person = добавить_память памяти, person
         when '('
            склад = :скобы
         when /^([а-яё]+)\.$/
            чин = $1
            log > { Чин: чин }
            person.чин = чин
         when /^[А-ЯЁ]/
            if person.имя.empty?
               имя = nocase && t || обращение( person, t, :имя )
               log > { Имя: имя }
               person.имя = имя
            else
               имя = nocase && t || обращение( person, t, :фамилия )
               log > { Прозвище: имя }
               person.прозвище.unshift имя
            end
         when /^[а-яё\dIVX\-\/]/
            имя = nocase && t || обращение( person, t, :фамилия )
            log > { Описание: имя }
            person.прозвище << имя
         when '.', ''
         else
            log % { 'Нерешённый склад' => t }
            $stderr.puts "Нерешённый склад #{t.inspect}" ; end
      end ; end

   # set чин
   чин = nil
   памяти.each do| person |
      if person.чин && !person.чин.empty?
         if person.чин[ -1 ] == person.чин[ -2 ]
            чин = person.чин[ 0..-2 ]
            person.чин = чин
         else
            чин = person.чин ; end
      else
         person.чин = чин ; end ; end

   # set год
   год = []
   памяти.reverse.each do| person |
      if person.событие.год && !person.событие.год.empty?
         год = person.событие.год
      else
         person.событие.год = год ; end ; end ; end

def и_исключение слово
   Исключения = [
      /ого[^А-ЯЁа-яё]*$/,
      /его[^А-ЯЁа-яё]*$/,
      /ой[^А-ЯЁа-яё]*$/,
   ]

   !Исключения.select {|s| слово =~ s }.empty?
end

def е_исключение слово
   Исключения = [
      /^святитель/,
      /^священник/,
      /^игумен/,
      /^чтец/,
      /^иеромонах/,
      /^прославление/,
      /^в$/,
      /^крещен/,
      /^бывш/,
   ]

   !Исключения.select {|s| слово =~ s }.empty?
end

def tokenize_line li, base
   # expanding groups
   lis = li.children.to_a.map do| li_e |
      if li_e.is_a?( Nokogiri::XML::Element ) && li_e.attr( 'href' ) =~ /group/
         url = li_e.attr( 'href' )
         uri = url =~ /^http/ && url || ( base + url )
         azbuka_group = Nokogiri::HTML( open( uri ), nil, 'utf-8' )
         ary = [ Nokogiri::XML::Text.new( 'Nocase', li_e ) ]
         ary.concat azbuka_group.css( "#featured .cont h1" ).children.to_a
         text = li_e.content
         if text =~ /(\(.*[\dIVX]+.*\))/
            ary << Nokogiri::XML::Text.new( $1.to_s, li_e ) ; end
         ary << Nokogiri::XML::Text.new( 'Case', li_e )
      else
         li_e ; end ; end.flatten

   current_uri = 'http://'
   tokens = [ current_uri ]
   lis.each do| li_e |
      link = false
      if li_e.is_a? Nokogiri::XML::Comment
         next ; end
      text = li_e.content.gsub( /["<!«»:]|--/, '' ).gsub( / +/, ' ' ).strip #NBSP to Space here
      log * ( '&'*80 )
      log >> { букы: text }
      uri =
      if li_e.is_a?( Nokogiri::XML::Element ) &&
         li_e.name == 'a'
         link = true
         if text !~ /^(?:[\dIVX]+|[^\(\),;А-Я]+[\dIVX]+)$/ &&
            li_e.attr( 'href' ) !~ /(\/(find|p-znaki|p-san|p-tip)|#)/
            log >> "Ссылка"
            url = li_e.attr( 'href' )
            url =~ /^http/ && url || ( base + url )
         else
            'http://' ; end
      else
         'http://' ; end

      t = text.split /\s+/, -1
      if tokens.size > 0 && !tokens.last.empty? &&
         tokens.last =~ /^[А-ЯЁа-яё]+$/ && tokens.last != 'и' &&
         uri == 'http://' && current_uri == uri && link &&
         !( t.empty? || t[ 0 ].empty? || t[ 0 ] == 'и' || t[ 0 ] =~ /^[А-ЯЁ]/ )

         log >> { "Прибавлена вещка" => t[ 0 ] }
         tokens.last << t.shift ; end

      if current_uri != uri
         log >> { "Добавлена ссылка" => uri }
         current_uri = uri
         tokens << uri ; end

      t.map! do| tt |
         a = tt.split( /[\(\)\.;,]/, -1 )
         tt.scan( /[\(\)\.;,]/ ) do | s |
            text = a.shift
            if s == '.' && text =~ /[а-яё]$/
               a.push( text << s )
            else
               a.push [ text, s ] ; end ; end
         a.push a.shift
      end.flatten!
      log >> { "Добавлен набор" => t } 

      tokens.concat t ; end

   log >> { tokens: tokens }
   tokens.map! {| t | ократчити_склад t }
   tokens.map!.with_index do| t, i |
      if t =~ /^[,;]$/
         tokens[ (i + 1)..-1 ].each do| tt |
            иск = tt =~ /\.\)?$/ || е_исключение( tt )
            ииск = и_исключение( tt )
#            if tt =~ /^(\(|http:\/\/.+)/ || tt =~ /\.$/ ||
            if tt =~ /^(http:\/\/.+)/ || tt =~ /\.$/ ||
               tt =~ /^[А-ЯЁ]/ && !иск && !ииск
               t = 'и'
               break
#            elsif tt =~ /^(?:http:\/\/|и|;|,)$/ || иск
            elsif ииск || иск || tt =~ /^(?:и|;|,)$/
               break ; end ; end ; end
      t !~ /^[,;]$/ && t || nil ; end.compact!

   log - ( tokens << 'и' ).flatten ; end

def to_people list
   people = {}
   list.each do| память |
      log >> { память: память }
      name = ''
      if !память.имя.empty?
         фамилия = память.фамилия.select {| имя | имя =~ /^[А-ЯЁ]/ }[ 0 ]
         прозвище = память.прозвище.select {| имя | имя =~ /^[А-ЯЁ]/ }[ 0 ]
         log > { фамилия => фамилия, прозвище => прозвище }
         name = [ память.имя, прозвище || фамилия ].compact.join ' ' ; end
      log >> { 'name' => name }
      log >> '*'*80

      if name.empty?
         name = ( !память.прозвище.empty? && память.прозвище ||
                память.описание ).join( ' ' ) ; end
      log > { 'name selected' => name }

      if people.key? name
         поплести_память people[ name ], память
      else
         people[ name ] = память ; end ; end
   people ; end


#date = ARGV.shift
date = Date.parse( ARGV.shift ) rescue Date.today
julian = date.julian
day = julian.day
month = julian.month
services = {}

Months = [ 'ЯНВАРЯ', 'ФЕВРАЛЯ', 'МАРТА', 'АПРЕЛЯ', 'МАЯ', 'ИЮНЯ',
           'ИЮЛЯ', 'АВГУСТА', 'СЕНТЯБРЯ', 'ОКТЯБРЯ', 'НОЯБРЯ', 'ДЕКАБРЯ' ]
month_str = Months[ month - 1 ]

log * "Search for #{day} #{month_str}\n\n"

# calendar
log * "Parse drevo-info.ru site"
log * ( "*"*80 )

uri = 'http://drevo-info.ru/articles/list/14.html?page='
date_link = 'http://drevo-info.ru' +
(1..4).each do| i |
   drevo_cal = Nokogiri::HTML( open "#{uri}#{i}" )
   li =
   drevo_cal.css( 'li' ).each do| li |
      if li.content == "#{day} #{month_str}" # check 27 НОЯБРЯ
         break li
      end
   end
   if li.is_a? Nokogiri::XML::Element
      break li.css( 'a' ).attr( 'href' ).value
   end
end

memlist = []
tokens = []
if date_link.is_a? String
   drevo_date = Nokogiri::HTML( open date_link )

   seg = drevo_date.css( 'h2' ).each do| h2 |
      if h2.text == 'Память'
         break h2 ; end ; end

   if !seg.is_a? Array
      #TODO change to seg
      mem = drevo_date.css( '#article ul' )
      mem.css( 'li' ).each do| li |
         if li.content.strip =~ /^\d/
            next ; end
         tokens.concat( tokenize_line li, 'http://drevo-info.ru' )
      end
   end
end

parse_tokens memlist, tokens

# Azbuka parsing
log * "Parse azbuka.ru site"
log * ( "*"*80 )

tokens = []
date_link = 'http://azbyka.ru/days'
doc = open "#{date_link}/#{date.strftime( "%Y-%m-%d" )}"
azbuka = Nokogiri::HTML doc.read, nil, 'utf-8'

ps = azbuka.css( '#calendar-wrapper .text p' )
ps.to_a.each_index do| i |
   if i == 0
      next ; end
   p = ps[ i ]
   tokens.concat( tokenize_line p, nil ) ; end

parse_tokens memlist, tokens, 'бытие'

# convert to hashie
#
people = to_people memlist

# req for manual merges
merges = []
people.keys.each.with_index do| имя, i |
   $stderr.print "#{i}. #{имя.inspect}\n? "
   line = $stdin.gets.strip
   if !line.empty?
      if /^>(?<target>.*)/ =~ line || people[ line ]
         target ||= line
         память = people[ target ]
         поплести_память память, people.delete( имя )
      else
         people[ line ] = people.delete( имя ) ; end ; end ; end

# Tropasions scan
#
assign_trops( ( azbuka.css '.taks_block .taks_content' ),
              people, services ) do| trop |
   names = trop.css( 'h3' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.glas' ).inner_text.scan( /\d+/ ).last rescue ''
   text = trop.css( 'div' ).inner_text.strip.gsub( /\s*\//, ' /' ).sub( /(?:\/\s*)?\/([^\/]+)$/, '//\1' )
   log > ( "#"*80 )
   log >> { names: names }
   [ names, glas, text, [ :dative, :genitive ] ] ; end

# Pravoslavie.ru parsing
log * "Parse Pravoslavie.ru site"
log * ( "*"*80 )

date_link = 'http://days.pravoslavie.ru/Days'
doc = open "#{date_link}/#{julian.strftime( "%Y%m%d" )}.htm"
prav_ru = Nokogiri::HTML doc.read

assign_trops( ( prav_ru.css '.trop' ),
              people, services ) do| trop |
   names = trop.css( '.trop_title' ).inner_text.strip.gsub( /[,'\(\)]+/, '' ).split( /\s+/ )
   glas = trop.css( '.trop_glas' ).inner_text.scan(/\d+/).last
   text = trop.css( '.trop_text' ).inner_text.strip.gsub( /\s*\//, ' /' ).sub( /(?:\/\s*)?\/([^\/]+)$/, '//\1' )
   log * ( "#"*80 )
   log >> { names: names }
   [ names, glas, text, [ :dative, :genitive ] ] ; end

# pravicon.com search
log * "Pravicon.ru search"
log * ( "*"*80 )

agent = Mechanize.new
#agent.user_agent_alias = 'Windows IE 9'

people.each do| имя, память |
   log >> { память: память }
   names = имя.split( /\s+/ )
   if names.empty?
      next ; end

   log > { name: names }
   page = agent.get 'http://pravicon.com/'
   f = page.forms.first
   f.search = names.shift
   f.selectdb = память.чин == 'обр' && 'b' || 's'
   log >> { form: f }
   begin
      content = f.submit( f.buttons.last ).content
      doc = Nokogiri::HTML content
   rescue
      next
   end

   uris = doc.css( '#content a' ).select do| a |
      log >> { 'match for' => a.content }
      names.reject {| name | a.content.include? name }.empty?
   end.map do| a |
      ( 'http://pravicon.com' + a.attr( 'href' ) )
   end

   if names.empty? && uris.size > 1
      next ; end
   case uris.size
   when 0
   when 1
      память.образ = [ uris.last ]
      if !память.бытие
         doc = Nokogiri::HTML( open uris.last )
         a = doc.css( ".spoiler a" )[ 0 ]
         if a
            память.бытие = 'http://pravicon.com' + a.attr( 'href' ) ; end ; end
   else
      память.образ = uris ; end ; end


people.keys.each do| имя |
   память = people[ имя ]
   log > { имя: имя, память: память }
   память.событие.год = память.событие.год.select{|a|!a.empty?}.join( ' ' ).strip
   память.событие.описание ||= 'прств'
   память.событие.дата = sprintf( "%.2i.%.2i", day, month )
   память.фамилия = память.фамилия.select{|a|!a.empty?}.join( ' ' ).strip
   память.прозвище = память.прозвище.select{|a|!a.empty?}.join( ' ' ).strip
   память.описание = память.описание.select{|a|!a.empty?}.join( ' ' ).strip
   память.служба = память.служба && память.служба.split( '/' ).last
   if память.событие.год =~ /19(\d\d)/
      num = $1.to_i 
      if num >= 17 && num <= 48
         память.собор << 'слав,нмр' ; end ; end
   память.собор = память.собор.select{|a|!a.empty?}.join( ',' ).strip
   память.образ = память.образ.select{|a|!a.empty?}.join( ',' ).strip

   people[ имя ] = память.to_hash.reject! {| _, з | з.nil? || з.empty? } ; end

folder = 'памяти'
people.each do| име, память |
   dir = File.join( folder, име )
   if File.exist? dir
      raise ; end
   FileUtils.mkdir_p dir
   File.open( File.join( dir, 'память.ро.yml' ), 'w' ) do| f |
      f.puts ({ име => people[ име ] }).to_yaml.gsub( /  /, '   ' ).gsub( / - /, '  - ' ).gsub( /['\[\]]+/, '' ).gsub( /\s+$/, '' )
   end
end

services.each do| име, служба |
   име = име.split( '/' )
   FileUtils.mkdir_p File.join( folder, име[ 0 ] )
   File.open( File.join( folder, име[ 0 ], име[ 1 ].to_s ), 'w' ) do| f |
      f.puts служба.to_yaml.gsub( /  /, '   ' ).gsub( / - /, '  - ' ).gsub( /'/, '' ).gsub( /\s+$/, '' ).gsub( /: !/, ':' )
   end
end

`git add памяти`
